---
title: "Transformando Dados"
author: "P4H"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      message = FALSE,
                      warning = FALSE)
library(tidyverse)
library(knitr)
```

## Introdução

No nosso último encontro, trabalhamos um pouco com importação de dados e _webscraping_. Uma vez que essa etapa é realizada, como proceder com o nosso banco de dados? Como transformá-lo para algo mais significado para nós? Hoje iremos entender como funciona a estruturação e a transformação de dados, de acordo com o _tidyverse approach_.

```{r, echo = FALSE, fig.align='center', fig.height=5.0, fig.width=7.0}
knitr::include_graphics('../imgs/w1_01.png')
```

## Estruturação

> tidy datasets are all alike but every messy dataset is messy in its own way (Hadley, 2014)

Estruturar um banco é uma tarefa __essencial__ antes de realizar qualquer operação. Uma banco desestruturado nos impede de transformar, visualizar e até modelar as nossas variáveis! Qual padrão iremos utilizar? Trabalharemos com bancos em que as linhas contêm observações; as colunas, variáveis e as células, valores.

```{r, echo = FALSE, fig.align='center', fig.height=5.0, fig.width=7.0}
knitr::include_graphics("../imgs/tidy-1.png")
```

## Como deixar os dados tidy com o `tidyr`.

O pacote `tidyr` possui funções que irão nos auxiliar durante o processo de _estruturação_ de um banco de dados. Ela é carregada com o comando `library(tidyverse)`.

Neste workshop, iremos trabalhar com o banco de dados sobre cursos _online_ oferecidos pelo MIT e pela Harvard.

```{r}
# Carrega o pacote tidyverse
library(tidyverse)

# Lê o banco de dado
banco <- read_csv('../data/w2/w2_01_use.csv') # Não se esqueça de alterar o caminho
```

Após carregar o nosso banco de dados, podemos dar uma "olhada rápida" por ele com a função `glimpse`.

```{r}
glimpse(banco)
```

### `gather`

Repare que as últimas quatro colunas não são exatamente variáveis. `2012`, `2013`, `2014`, `2015` e `2016` na verdade são valores de uma outra variável, ao mesmo tempo que as células correspondentes a essas variáveis dizem respeito também a outra variável. Você saberia dizer tendo em vista apenas os valores quais são essas __duas__ variáveis?

```{r}
banco <- gather(banco, c("2012", "2013", "2014", "2015", "2016"), key = "year", value = "institutions")
```

Se você está familiarizado com a notação _wide_ e _long_, o que acabamos de fazer foi transformar um banco com características _wide_ em um _long_. É possível ir além e afirmar que o formato _tidy data_ sempre é um banco _long_.

## `spread`, `separate` e `unite`

## Os principais verbos do dplyr.

### filter

### mutate

Por que transformar os nossos dados? Após importar um banco para o R, antes de realizar qualquer análise, precisamos (1) garantir que as nossas variáveis estão limpas, ou seja, que todos os valores estão condizentes com o padrão esperado (2) e, às vezes, precisamos _recodificá-las_ para algo com mais significado para nós.

Vamos ver alguns exemplos, antes de continuar. O que entendemos por limpar um banco? Imagine que ao coletar a renda de alguns indivíduos você tenha introduzido um hífem para identificar não respostas. 

```{r, echo = FALSE}
tibble(RENDA = c("19991,32", "-", "-", "829,23", "9293,12", "839,79"),
       RENDA_NEW = c(19991.32, NA, NA, 829.23, 9293.12, 839.79)) %>% 
  kable(caption = "Exemplo de Variável Não Limpa")
```

Embora isso possa ser considerado um procedimento válido durante a coleta, ele irá causar problemas durante a nossa análise. Uma vez que "-" é um texto, o R não sabe como compará-lo com valores numéricos (19991.32, por exemplo). Nesse sentido, precisamos explicitar para o R que "-" na verdade é um valor _missing_. Iremos ver que, na prática, transformaremos o "-" em NA através das funções `mutate` e `ifelse`.

Outro exemplo de transformação é a necessidade de _recodificação_ os valores de uma variável. Estamos falando, por exemplo, de criação de faixas para variáveis contínuas, reclassificação de variáveis categóricas, inflacionar/deflacionar valores monetários, etc. Um caso prático é a reclassificação das categorias do IBGE para valores com maior significado sociológico. É relaticamente comum classificar indíginas, pretos e pardos como não-brancos para fins de análise de desigualdade racial.

```{r, echo = FALSE}
tibble(RACA_IBGE = c('INDÍGENA', 'PRETA', 'PARDA', 'BRANCA'),
       RACA_NEW  = c('NÃO BRANCOS', 'NÃO BRANCOS', 'NÃO BRANCOS', 'BRANCOS')) %>% 
  kable(caption = 'Exemplo de Recodificação')
```

Uma vez que você tenha entendido para que precisamos transformar os nossos dados, vamos colocar a mão na massa e tentar realizar essa atividade por meio códigos!!!

A estrutura para modificar variáveis no R por meio do `tidyverse` segue sempre o mesmo padrão:

```{r, eval = FALSE}
mutate(BANCO_DE_DADOS,
       VARIAVEL QUE QUEREMOS CRIAR/MODIFICAR    =   VALOR QUE A VARIÁVEL IRÁ RECEBER)
```

`mutate` é uma função bem versátil e será muito utilizada por você sempre que quiser __acessar__ as variáveis de um `data frame`. Experimente por exemplo criar uma coluna com 
